const { Client } = require('./client')
const { RakClient } = require('./rak')('raknet-native')
const { sleep } = require('./datatypes/util')
const assert = require('assert')
const Options = require('./options')
const advertisement = require('./server/advertisement')
const auth = require('./client/auth')
const fs = require('fs')

/** @param {{ version?: number, host: string, port?: number, connectTimeout?: number, skipPing?: boolean }} options */
function createClient (options) {
  assert(options)
  const client = new Client({ port: 19132, followPort: !options.realms, ...options, delayedInit: true })

  function onServerInfo () {
    client.on('connect_allowed', () => connect(client))
    if (options.skipPing) {
      client.init()
    } else {
      ping(client.options).then(ad => {
        const adVersion = ad.version?.split('.').slice(0, 3).join('.') // Only 3 version units
        client.options.version = options.version ?? (Options.Versions[adVersion] ? adVersion : Options.CURRENT_VERSION)

        if (ad.portV4 && client.options.followPort) {
          client.options.port = ad.portV4
        }

        client.conLog?.(`Connecting to ${client.options.host}:${client.options.port} ${ad.motd} (${ad.levelName}), version ${ad.version} ${client.options.version !== ad.version ? ` (as ${client.options.version})` : ''}`)
        client.init()
      }).catch(e => client.emit('error', e))
    }
  }

  if (options.realms) {
    auth.realmAuthenticate(client.options).then(onServerInfo).catch(e => client.emit('error', e))
  } else {
    onServerInfo()
  }
  return client
}

function connect (client) {
  // Actually connect
  client.connect()

  client.once('resource_packs_info', (packet) => {

    const texturesUuid = [];
    packet.texture_packs.forEach((value) => {
      texturesUuid.push(value.uuid)
    })
    client.write('resource_pack_client_response', {
      response_status: 'send_packs',
      resourcepackids: texturesUuid
    })
    const ressouceFixDuplication = new Map();
    const ressouceChunkMax = new Map();
    const resourceStart = [];
    const ressouceFinish = [];
    client.on('resource_pack_data_info', (test) => {
      ressouceChunkMax.set(test.pack_id, test.chunk_count - 1);
      for (let chunk = 0; chunk < test.chunk_count; chunk++) {
        client.queue('resource_pack_chunk_request', {pack_id: test.pack_id, chunk_index: chunk});
      }

      client.on('resource_pack_chunk_data', (packet2) => {
        if (!ressouceFixDuplication.has(packet2.pack_id)) {
          ressouceFixDuplication.set(packet2.pack_id, []);
        }

        if (!ressouceFixDuplication.get(packet2.pack_id).includes(packet2.chunk_index)) {

          ressouceFixDuplication.get(packet2.pack_id).push(packet2.chunk_index)
          fs.writeFileSync(`./pack/tmp/${packet2.pack_id}_${packet2.chunk_index}.buffer`, packet2.payload, {encoding: "binary"});
          if (ressouceChunkMax.get(packet2.pack_id) === packet2.chunk_index) {

            let fileContents;
            ressouceFixDuplication.get(packet2.pack_id).forEach((chunk_index) => {
              fileContents += fs.readFileSync(`./pack/tmp/${packet2.pack_id}_${chunk_index}.buffer`, {encoding: "binary"});
              fs.unlinkSync(`./pack/tmp/${packet2.pack_id}_${chunk_index}.buffer`);
            })
            fs.writeFileSync(`./pack/${packet2.pack_id}.zip`, fileContents, {encoding: "binary"}, function (err) {
            });

            ressouceFinish.push(packet2.pack_id)
            if (ressouceFinish.length === texturesUuid.length){
              client.write('resource_pack_client_response', {
                response_status: 'have_all_packs',
                resourcepackids: ressouceFinish
              })
              client.emit('resource_pack_client_response', {
                response_status: 'have_all_packs',
                resourcepackids: ressouceFinish
              })

              client.once('resource_pack_stack', (stack) => {
                client.write('resource_pack_client_response', {
                  response_status: 'completed',
                  resourcepackids: ressouceFinish
                })
              })
              client.queue('client_cache_status', { enabled: false })
              client.queue('tick_sync', { request_time: BigInt(Date.now()), response_time: 0n })
              sleep(500).then(() => client.queue('request_chunk_radius', { chunk_radius: client.viewDistance || 10 }))
            }
          }
        }
      })
    })
  });

  // Send tick sync packets every 10 ticks
  const keepAliveInterval = 10
  const keepAliveIntervalBig = BigInt(keepAliveInterval)
  let keepalive
  client.tick = 0n
  client.once('spawn', () => {
    keepalive = setInterval(() => {
      // Client fills out the request_time and the server does response_time in its reply.
      client.queue('tick_sync', { request_time: client.tick, response_time: 0n })
      client.tick += keepAliveIntervalBig
    }, 50 * keepAliveInterval)

    client.on('tick_sync', async packet => {
      client.emit('heartbeat', packet.response_time)
      client.tick = packet.response_time
    })
  })

  client.once('close', () => {
    clearInterval(keepalive)
  })
}

async function ping ({ host, port }) {
  const con = new RakClient({ host, port })
  try {
    return advertisement.fromServerName(await con.ping())
  } finally {
    con.close()
  }
}

module.exports = { createClient, ping }
